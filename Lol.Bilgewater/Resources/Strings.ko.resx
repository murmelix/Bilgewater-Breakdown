<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="All" xml:space="preserve">
    <value>모든</value>
  </data>
  <data name="Assassin" xml:space="preserve">
    <value>암살자</value>
  </data>
  <data name="Assists" xml:space="preserve">
    <value>도움</value>
  </data>
  <data name="Champions" xml:space="preserve">
    <value>챔피언스</value>
  </data>
  <data name="Charts" xml:space="preserve">
    <value>차트</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>닫기</value>
  </data>
  <data name="CS" xml:space="preserve">
    <value>CS</value>
  </data>
  <data name="DataProcessing" xml:space="preserve">
    <value>데이터 처리</value>
  </data>
  <data name="DataText1" xml:space="preserve">
    <value>폭동 API의 데이터를 처리하기 위해, 우리는 개별 데이터 객체를 나타낸다 작은 라이브러리를 썼다. 나중에 우리가 발견,이 같은 뭔가가 이미 존재했다.</value>
  </data>
  <data name="DataText2" xml:space="preserve">
    <value>많은 경기 데이터를로드하기 위해, 우리는 매개 변수로 API 키와 지역을 인수 작은 콘솔 프로그램을 썼다. 사용자는 다운로드 프로세스를 가속화하기 위해 프로그램의 다중 인스턴스를 시작할 수있다.데이터는 라이브러리 공간을 절약하는 압축 된 {0}</value>
  </data>
  <data name="DataText3" xml:space="preserve">
    <value>상대적으로 완전한 일치하는 정보에서 중요한 데이터를 추출하기 위해, 우리는 두 번째 콘솔 프로그램을 썼다. 이것은 단지 우리가 흥미로 우리의 분석을 위해 고려 일치 JSON - 파일에서 모든 데이터 값을 추출했다.JSON-파일을 구문 분석을 위해 우리는 도서관 {1} 사용이 있습니다.데이터는 직렬화 라이브러리 protobuf 함께 배양 하였다. {0} 구글의 직렬화 믿을 수 없을만큼 빠르고 세련된 방법이다. /&gt; &lt;br 그 후, 우리는 단지 분석하고 작은 샘플 데이터 값에 값을 저장했다.데이터베이스는 필요하지 않았다.</value>
  </data>
  <data name="Death" xml:space="preserve">
    <value>죽음</value>
  </data>
  <data name="Documentation" xml:space="preserve">
    <value>설명서</value>
  </data>
  <data name="DurationStats" xml:space="preserve">
    <value>통계 경기 길이</value>
  </data>
  <data name="Fighter" xml:space="preserve">
    <value>전투기</value>
  </data>
  <data name="FirstBaron" xml:space="preserve">
    <value>우선 바론</value>
  </data>
  <data name="FirstBlood" xml:space="preserve">
    <value>먼저 혈액</value>
  </data>
  <data name="FirstDrake" xml:space="preserve">
    <value>먼저 드레이크</value>
  </data>
  <data name="FirstInhibitor" xml:space="preserve">
    <value>먼저 억제제</value>
  </data>
  <data name="FirstTower" xml:space="preserve">
    <value>첫 번째 타워</value>
  </data>
  <data name="Items" xml:space="preserve">
    <value>항목</value>
  </data>
  <data name="Kills" xml:space="preserve">
    <value>킬</value>
  </data>
  <data name="LetsGo" xml:space="preserve">
    <value>가자</value>
  </data>
  <data name="LowesPickrate" xml:space="preserve">
    <value>최저 피크 속도</value>
  </data>
  <data name="LowestAvgCS" xml:space="preserve">
    <value>최고 평균 CS</value>
  </data>
  <data name="LowestWinrate" xml:space="preserve">
    <value>최저 승 속도</value>
  </data>
  <data name="Mage" xml:space="preserve">
    <value>마술사</value>
  </data>
  <data name="Marksman" xml:space="preserve">
    <value>사격의 명수</value>
  </data>
  <data name="Matchduration" xml:space="preserve">
    <value>경기 시간</value>
  </data>
  <data name="MercPopularity" xml:space="preserve">
    <value>용병 인기</value>
  </data>
  <data name="OnlyBilgewater" xml:space="preserve">
    <value>만 Bilgewater</value>
  </data>
  <data name="Pickrate" xml:space="preserve">
    <value>속도를 선택</value>
  </data>
  <data name="Presentation" xml:space="preserve">
    <value>제출</value>
  </data>
  <data name="PresentationText1" xml:space="preserve">
    <value>사이트의 디자인을 위해, 우리는 주제로 {0} 사용합니다. 부트 스트랩으로 세련된 레이아웃을 만들 비교적 쉽게 할 수 있습니다.차트의 경우, 우리는 자바 스크립트 라이브러리 {1}에 대한 선택했다. 이것은 상대적으로 편안하게 사용하는 것입니다, 그러나 우리는 X 축 수에 아이콘을 표시하기 위해 작은 조정했습니다.</value>
  </data>
  <data name="PresentationText2" xml:space="preserve">
    <value>추가 기술</value>
  </data>
  <data name="Region" xml:space="preserve">
    <value>지방</value>
  </data>
  <data name="RoleStats" xml:space="preserve">
    <value>통계 역할 성능</value>
  </data>
  <data name="Support" xml:space="preserve">
    <value>지원</value>
  </data>
  <data name="Tank" xml:space="preserve">
    <value>탱크</value>
  </data>
  <data name="TearNote" xml:space="preserve">
    <value>눈물은 플레이어가 용병 중 하나를 선택하지 않은 경우를 나타냅니다.</value>
  </data>
  <data name="Tools" xml:space="preserve">
    <value>도구</value>
  </data>
  <data name="ToolsText1" xml:space="preserve">
    <value>개발을 위해 우리가 주로 사용 {0}. 마이크로 소프트 양식 개발 환경은 노 상업 프로젝트에 무료로 사용할 수 있습니다. 그것은 MVC 웹 응용 프로그램을 매우 쉽게 개발할 수 있습니다.</value>
  </data>
  <data name="ToolsText2" xml:space="preserve">
    <value>프로그램이 매우 간단 GIT-통합 및에 합병증없이 프로젝트를 게시 할 수있는 옵션을 제공 외에 당신의 {0}. 또한 모든 추가 라이브러리 프로젝트에서 nuget 통합을 통해 쉽게 인출 할 수 있습니다. 우리는 우리의 모든 외부 라이브러리를했다.</value>
  </data>
  <data name="TopAvgCS" xml:space="preserve">
    <value>최고 평균 CS</value>
  </data>
  <data name="TopPickrate" xml:space="preserve">
    <value>최고 피크 속도</value>
  </data>
  <data name="TopWinrate" xml:space="preserve">
    <value>탑 승 속도</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>환영</value>
  </data>
  <data name="WelcomeText1" xml:space="preserve">
    <value>API-도전 2.0 우리의 항목과 우리는 가능한 주제의 1로 바치고 싶었 :</value>
  </data>
  <data name="WelcomeText2" xml:space="preserve">
    <value>우리는 정보의 어느 대해 재미있을 거라고 생각합니다. 우리의 주요 목표는 게임 길이가 강한 부하의 영향을받는 경우 용병은 플레이어베이스 사이에서 가장 인기가 어느 분석했다.</value>
  </data>
  <data name="WelcomeText3" xml:space="preserve">
    <value>또한으로 우리는 모든 챔피언과 아이템의 성능에서 통계를 추가했다.</value>
  </data>
  <data name="Winrate" xml:space="preserve">
    <value>승 속도</value>
  </data>
  <data name="ConclusionChampions" xml:space="preserve">
    <value>모든 챔피언을 통해 가장 큰 차이점은 연사를 allover의 큰 손실이다. 빌지 워터의 모든 상단 농부들은 농장에서 약 20 % 낮다.</value>
  </data>
  <data name="ConclusionDuration" xml:space="preserve">
    <value>빌지 워터 일치의 기간은 defenitly 빠르다. 대부분의 목표는 earlyier 드레이크를 제외하고, 촬영.</value>
  </data>
  <data name="ConclusionMercPopularity" xml:space="preserve">
    <value>근접 용병은 더 인기가있을 것 같다,하지만 winrate 공정 배포됩니다. 플레이어의 매우 놀라게 큰 숫자는 용병을 구입하지 않았다.</value>
  </data>
  <data name="ConclusionRoles" xml:space="preserve">
    <value>서로 다른 역할의 성공에 더 큰 variancy 없습니다. 탱크와 전투기에 마이너 푸시.</value>
  </data>
</root>