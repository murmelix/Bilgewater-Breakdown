<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="All" xml:space="preserve">
    <value>Tutti</value>
  </data>
  <data name="Assassin" xml:space="preserve">
    <value>Assassino</value>
  </data>
  <data name="Assists" xml:space="preserve">
    <value>Assists</value>
  </data>
  <data name="Champions" xml:space="preserve">
    <value>Champions</value>
  </data>
  <data name="Charts" xml:space="preserve">
    <value>Grafici</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>Chiudere</value>
  </data>
  <data name="CS" xml:space="preserve">
    <value>CS</value>
  </data>
  <data name="DataProcessing" xml:space="preserve">
    <value>Elaborazione dati</value>
  </data>
  <data name="DataText1" xml:space="preserve">
    <value>Al fine di elaborare i dati di Riot Api abbiamo scritto una piccola biblioteca, che mappa gli oggetti di dati einzelen. Solo più tardi abbiamo herrausgefunden che c'è già qualcosa di simile.</value>
  </data>
  <data name="DataText2" xml:space="preserve">
    <value>Per caricare i molti dati match, abbiamo scritto un piccolo programma di console, che riprende la chiave API e di una regione come parametro. Si potrebbe iniziare più istanze del programma, al fine di accelerare il processo di download. I dati sono stati quindi compressi per risparmiare spazio con la biblioteca-{0}.</value>
  </data>
  <data name="DataText3" xml:space="preserve">
    <value>Per estrarre i dati importanti dalle informazioni partita relativamente completo, abbiamo scritto un secondo programma di console. Questo ha soltanto degli estratti tutti i valori dei dati dal match-JSON-Files, che abbiamo preso in considerazione per la nostra analisi come interessante. Per l'analisi del JSON-Files abbiamo la biblioteca {1} usato. I dati sono stati poi incubate con la libreria-protobuf serializzato. {0} è un metodo incredibilmente veloce ed elegante per la serializzazione di Google. &lt;br /&gt; Dopo di che, abbiamo avuto solo di analizzare e memorizzare i valori in piccoli campioni i valori dei dati. Un database non era necessario.</value>
  </data>
  <data name="Death" xml:space="preserve">
    <value>Morte</value>
  </data>
  <data name="Documentation" xml:space="preserve">
    <value>Documentazione</value>
  </data>
  <data name="DurationStats" xml:space="preserve">
    <value>Statistica Partita Lunghezza</value>
  </data>
  <data name="Fighter" xml:space="preserve">
    <value>combattente</value>
  </data>
  <data name="FirstBaron" xml:space="preserve">
    <value>barone</value>
  </data>
  <data name="FirstBlood" xml:space="preserve">
    <value>sangue</value>
  </data>
  <data name="FirstDrake" xml:space="preserve">
    <value>Drake</value>
  </data>
  <data name="FirstInhibitor" xml:space="preserve">
    <value>Inhibitor</value>
  </data>
  <data name="FirstTower" xml:space="preserve">
    <value>Torre</value>
  </data>
  <data name="Items" xml:space="preserve">
    <value>Items</value>
  </data>
  <data name="Kills" xml:space="preserve">
    <value>Kills</value>
  </data>
  <data name="LetsGo" xml:space="preserve">
    <value>Andiamo</value>
  </data>
  <data name="LowesPickrate" xml:space="preserve">
    <value>Più basso tasso di ritiro</value>
  </data>
  <data name="LowestAvgCS" xml:space="preserve">
    <value>Minore Avg CS</value>
  </data>
  <data name="LowestWinrate" xml:space="preserve">
    <value>Più basso tasso di Win</value>
  </data>
  <data name="Mage" xml:space="preserve">
    <value>Mage</value>
  </data>
  <data name="Marksman" xml:space="preserve">
    <value>tiratore scelto</value>
  </data>
  <data name="Matchduration" xml:space="preserve">
    <value>durata</value>
  </data>
  <data name="MercPopularity" xml:space="preserve">
    <value>Mercenari Popolarità</value>
  </data>
  <data name="OnlyBilgewater" xml:space="preserve">
    <value>solo Bilgewater</value>
  </data>
  <data name="Pickrate" xml:space="preserve">
    <value>Scegli tasso</value>
  </data>
  <data name="Presentation" xml:space="preserve">
    <value>Presentazione</value>
  </data>
  <data name="PresentationText1" xml:space="preserve">
    <value>Per la progettazione del sito, usiamo {0} con il tema. Con bootstrap può essere relativamente facile per creare un layout elegante. Per le classifiche, abbiamo optato per la libreria javascript {1}. Questo è quello di utilizzare relativamente confortevole, ma abbiamo dovuto fare un piccolo aggiustamento al fine di visualizzare le icone nella latta asse X.</value>
  </data>
  <data name="PresentationText2" xml:space="preserve">
    <value>tecnologie aggiuntive</value>
  </data>
  <data name="Region" xml:space="preserve">
    <value>Regione</value>
  </data>
  <data name="RoleStats" xml:space="preserve">
    <value>Statistica Prestazioni Ruolo</value>
  </data>
  <data name="Support" xml:space="preserve">
    <value>Supporto</value>
  </data>
  <data name="Tank" xml:space="preserve">
    <value>Carro armato</value>
  </data>
  <data name="TearNote" xml:space="preserve">
    <value>La lacrima rappresenta i casi in cui il giocatore non scegliere uno qualsiasi dei mercenari.</value>
  </data>
  <data name="Tools" xml:space="preserve">
    <value>Strumenti</value>
  </data>
  <data name="ToolsText1" xml:space="preserve">
    <value>Per lo sviluppo abbiamo utilizzato principalmente {0}. L'ambiente di sviluppo modulo di Microsoft è disponibile gratuitamente, senza mezzi commerciali progetti. Rende sviluppo di applicazioni web MVC molto facile.</value>
  </data>
  <data name="ToolsText2" xml:space="preserve">
    <value>Oltre al programma offre una molto semplice GIT-integrazione e la possibilità di pubblicare il progetto senza complicazioni sul {0}. Inoltre ogni libreria aggiuntiva può essere facilmente recuperato attraverso l'integrazione NuGet nel progetto. Lo abbiamo fatto per tutti i nostri librerie esterne.</value>
  </data>
  <data name="TopAvgCS" xml:space="preserve">
    <value>Top Avg CS</value>
  </data>
  <data name="TopPickrate" xml:space="preserve">
    <value>Tasso Top Pick</value>
  </data>
  <data name="TopWinrate" xml:space="preserve">
    <value>Top Win tasso</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>Benvenuto</value>
  </data>
  <data name="WelcomeText1" xml:space="preserve">
    <value>Con la nostra voce per l'API-Challenge 2.0 abbiamo voluto dedicare al 1. di possibili argomenti:</value>
  </data>
  <data name="WelcomeText2" xml:space="preserve">
    <value>Abbiamo pensato che delle informazioni potrebbe essere interessante. Il nostro obiettivo primario è stato quello di analizzare quali mercenari sono stati più popolare tra la base di giocatori e se la lunghezza gioco sarebbe influenzato dai tirapiedi forti.</value>
  </data>
  <data name="WelcomeText3" xml:space="preserve">
    <value>In aggiunta abbiamo aggiunto alcune statistiche da prestazioni di ogni campione e la voce.</value>
  </data>
  <data name="Winrate" xml:space="preserve">
    <value>Win tasso</value>
  </data>
  <data name="ConclusionChampions" xml:space="preserve">
    <value>La differenza più grande su tutti i campioni è la perdita significativa in CS allover. Tutti i migliori agricoltori in bilgewater sono inferiori di circa il 20% in agriturismo.</value>
  </data>
  <data name="ConclusionDuration" xml:space="preserve">
    <value>La durata di partite Bilgewater è defenitly più veloce. Più gol sono earlyier prese, ad eccezione di Drake.</value>
  </data>
  <data name="ConclusionMercPopularity" xml:space="preserve">
    <value>I mercenari mischia sembrano essere più popolare, ma il tasso di vincita è giusto distribuiti. Un suprising gran numero di giocatori, non ha acquistato un mercenario.</value>
  </data>
  <data name="ConclusionRoles" xml:space="preserve">
    <value>Nessun grande il variare in caso di successo di diversi ruoli. Spinta minore sul serbatoio e combattente.</value>
  </data>
</root>