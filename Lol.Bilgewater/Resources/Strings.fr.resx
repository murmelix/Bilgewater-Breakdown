<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="All" xml:space="preserve">
    <value>Tous</value>
  </data>
  <data name="Assassin" xml:space="preserve">
    <value>Assassin</value>
  </data>
  <data name="Assists" xml:space="preserve">
    <value>assiste</value>
  </data>
  <data name="Champions" xml:space="preserve">
    <value>Champions</value>
  </data>
  <data name="Charts" xml:space="preserve">
    <value>Graphiques</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>Fermer</value>
  </data>
  <data name="CS" xml:space="preserve">
    <value>CS</value>
  </data>
  <data name="DataProcessing" xml:space="preserve">
    <value>Le traitement des données</value>
  </data>
  <data name="DataText1" xml:space="preserve">
    <value>Afin de traiter les données de Riot Api, nous avons écrit une petite bibliothèque, qui montre les objets de données individuels. Plus tard, nous avons découvert que quelque chose comme cela existait déjà.</value>
  </data>
  <data name="DataText2" xml:space="preserve">
    <value>Pour charger les nombreuses données de match, nous avons écrit un petit programme de la console, qui prend en charge la clé API et une région en tant que paramètre. Vous pouvez lancer plusieurs instances du programme afin d'accélérer le processus de téléchargement. Les données ont été ensuite comprimé pour économiser l'espace avec la bibliothèque {0}</value>
  </data>
  <data name="DataText3" xml:space="preserve">
    <value>Pour extraire les données importantes de l'information relativement complète du match, nous avons écrit un deuxième programme de la console. Cela n'a extrait toutes les valeurs de données du match JSON-Files, que nous considérons pour notre analyse aussi intéressant. Pour l'analyse du JSON-Files nous avons la bibliothèque {1} utilisé. Les données ont ensuite été incubées avec le serialize bibliothèque protobuf. {0} est une méthode incroyablement rapide et élégant pour la sérialisation de Google. &lt;br /&gt; Après cela, nous avons seulement eu à analyser et stocker les valeurs dans de petits échantillons des valeurs de données. Une base de données n'a pas été nécessaire.</value>
  </data>
  <data name="Death" xml:space="preserve">
    <value>Décès</value>
  </data>
  <data name="Documentation" xml:space="preserve">
    <value>Documentation</value>
  </data>
  <data name="DurationStats" xml:space="preserve">
    <value>La statistique match Longueur</value>
  </data>
  <data name="Fighter" xml:space="preserve">
    <value>combattant</value>
  </data>
  <data name="FirstBaron" xml:space="preserve">
    <value>baron</value>
  </data>
  <data name="FirstBlood" xml:space="preserve">
    <value>sang</value>
  </data>
  <data name="FirstDrake" xml:space="preserve">
    <value>Drake</value>
  </data>
  <data name="FirstInhibitor" xml:space="preserve">
    <value>inhibiteur</value>
  </data>
  <data name="FirstTower" xml:space="preserve">
    <value>Tour</value>
  </data>
  <data name="Items" xml:space="preserve">
    <value>articles</value>
  </data>
  <data name="Kills" xml:space="preserve">
    <value>tués</value>
  </data>
  <data name="LetsGo" xml:space="preserve">
    <value>Laisse nous partir</value>
  </data>
  <data name="LowesPickrate" xml:space="preserve">
    <value>Prix Pick</value>
  </data>
  <data name="LowestAvgCS" xml:space="preserve">
    <value>le plus bas Avg CS</value>
  </data>
  <data name="LowestWinrate" xml:space="preserve">
    <value>le plus bas Win</value>
  </data>
  <data name="Mage" xml:space="preserve">
    <value>Mage</value>
  </data>
  <data name="Marksman" xml:space="preserve">
    <value>Marksman</value>
  </data>
  <data name="Matchduration" xml:space="preserve">
    <value>Duration</value>
  </data>
  <data name="MercPopularity" xml:space="preserve">
    <value>Popularité Mercenary</value>
  </data>
  <data name="OnlyBilgewater" xml:space="preserve">
    <value>que Bilgewater</value>
  </data>
  <data name="Pickrate" xml:space="preserve">
    <value>taux Choisissez</value>
  </data>
  <data name="Presentation" xml:space="preserve">
    <value>présentation</value>
  </data>
  <data name="PresentationText1" xml:space="preserve">
    <value>Pour la conception du site, nous utilisons {0} avec le thème. Avec bootstrap peut être relativement facile de créer une mise en page chic. Pour les graphiques, nous avons opté pour la bibliothèque javascript {1}. Ceci est d'utiliser relativement confortable, mais nous avons dû faire un petit ajustement afin d'afficher les icônes dans l'axe X-boîte.</value>
  </data>
  <data name="PresentationText2" xml:space="preserve">
    <value>D'autres technologies</value>
  </data>
  <data name="Region" xml:space="preserve">
    <value>Région</value>
  </data>
  <data name="RoleStats" xml:space="preserve">
    <value>Rôle de la performance statistique</value>
  </data>
  <data name="Support" xml:space="preserve">
    <value>Soutien</value>
  </data>
  <data name="Tank" xml:space="preserve">
    <value>Tank</value>
  </data>
  <data name="TearNote" xml:space="preserve">
    <value>La larme représente les cas où le joueur n'a pas de choisir un des mercanaries.</value>
  </data>
  <data name="Tools" xml:space="preserve">
    <value>outils</value>
  </data>
  <data name="ToolsText1" xml:space="preserve">
    <value>Pour le développement, nous avons utilisé principalement {0}. Forme Microsoft L'environnement de développement est disponible gratuitement, en aucun-projets commerciaux. Il permet le développement d'applications Web MVC très facile.</value>
  </data>
  <data name="ToolsText2" xml:space="preserve">
    <value>Outre le Programme offre une GIT-intégration très simple et une option pour publier votre projet sans complications sur votre {0}. Chaque bibliothèque supplémentaire peut également être facilement récupérée par l'intégration NuGet dans votre projet. Nous l'avons fait pour tous nos bibliothèques externes.</value>
  </data>
  <data name="TopAvgCS" xml:space="preserve">
    <value>Top Avg CS</value>
  </data>
  <data name="TopPickrate" xml:space="preserve">
    <value>Taux de premier choix</value>
  </data>
  <data name="TopWinrate" xml:space="preserve">
    <value>Haut taux de victoires</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>Bienvenue</value>
  </data>
  <data name="WelcomeText1" xml:space="preserve">
    <value>Avec notre entrée de l'API-Challenge 2.0 nous voulions consacrer au 1. de sujets possibles:</value>
  </data>
  <data name="WelcomeText2" xml:space="preserve">
    <value>Nous avons pensé à des informations qui pourrait être intéressant. Notre principal objectif était d'analyser les mercenaires étaient les plus populaires parmi les playerbase et si le gamelength serait affecté par sbires fortes.</value>
  </data>
  <data name="WelcomeText3" xml:space="preserve">
    <value>En complément, nous avons ajouté quelques statistiques de la performance de chaque champion et un objet</value>
  </data>
  <data name="Winrate" xml:space="preserve">
    <value>Taux de réussite</value>
  </data>
  <data name="ConclusionChampions" xml:space="preserve">
    <value>La plus grande différence sur tous les champions est la perte significative de CS allover. Tous les meilleurs agriculteurs dans bilgewater sont environ 20% plus faible dans la ferme.</value>
  </data>
  <data name="ConclusionDuration" xml:space="preserve">
    <value>La durée des matchs est Bilgewater defenitly plus rapide. La plupart des objectifs sont earlyier prises, sauf drake.</value>
  </data>
  <data name="ConclusionMercPopularity" xml:space="preserve">
    <value>Les mercenaires de mêlée semblent être plus populaire, mais le winrate est juste distribués. Un grand nombre surprenant de joueurs, ne pas acheter un mercenaire.</value>
  </data>
  <data name="ConclusionRoles" xml:space="preserve">
    <value>Pas de grosse variance totale en cas de succès de rôles différents. Poussoir mineure sur le réservoir et combattant.</value>
  </data>
</root>