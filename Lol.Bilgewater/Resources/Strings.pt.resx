<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="All" xml:space="preserve">
    <value>tudo</value>
  </data>
  <data name="Assassin" xml:space="preserve">
    <value>assassino</value>
  </data>
  <data name="Assists" xml:space="preserve">
    <value>assistências</value>
  </data>
  <data name="Champions" xml:space="preserve">
    <value>campeões</value>
  </data>
  <data name="Charts" xml:space="preserve">
    <value>charts</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>Fechar</value>
  </data>
  <data name="CS" xml:space="preserve">
    <value>CS</value>
  </data>
  <data name="DataProcessing" xml:space="preserve">
    <value>Processamento de dados</value>
  </data>
  <data name="DataText1" xml:space="preserve">
    <value>A fim de processar os dados de motim Api, nós escrevemos uma pequena biblioteca, que mostra os objetos de dados individuais. Mais tarde, descobri, que algo como isso já existia.</value>
  </data>
  <data name="DataText2" xml:space="preserve">
    <value>Para carregar os dados de muitos jogos, nós escrevemos um programa pequeno console, que assume a chave de API e uma região como um parâmetro. Você pode começar várias instâncias do programa, a fim de acelerar o processo de download. Os dados foram então comprimido para economizar espaço com a biblioteca {0}</value>
  </data>
  <data name="DataText3" xml:space="preserve">
    <value>Para extrair os dados importantes a partir da informação relativamente completa jogo, que escreveu um segundo programa de console. Isto só extrai todos os valores de dados a partir do match-JSON-Files, que foi considerado para a nossa análise tão interessante. Para analisar o JSON-Files temos a biblioteca {1} utilizado. Os dados foram então incubadas com a biblioteca de protobuf serializados. {0} é um método incrivelmente rápida e elegante para serialização de Google. &lt;br /&gt; Depois disso, nós só tivemos que analisar e armazenar os valores em pequenas amostras de dados dos valores. Um banco de dados não foi necessário.</value>
  </data>
  <data name="Death" xml:space="preserve">
    <value>morte</value>
  </data>
  <data name="Documentation" xml:space="preserve">
    <value>documentação</value>
  </data>
  <data name="DurationStats" xml:space="preserve">
    <value>Comprimento Estatísticas dos jogos</value>
  </data>
  <data name="Fighter" xml:space="preserve">
    <value>lutador</value>
  </data>
  <data name="FirstBaron" xml:space="preserve">
    <value>Baron</value>
  </data>
  <data name="FirstBlood" xml:space="preserve">
    <value>sangue</value>
  </data>
  <data name="FirstDrake" xml:space="preserve">
    <value>Drake</value>
  </data>
  <data name="FirstInhibitor" xml:space="preserve">
    <value>inibidor</value>
  </data>
  <data name="FirstTower" xml:space="preserve">
    <value>Torre</value>
  </data>
  <data name="Items" xml:space="preserve">
    <value>itens</value>
  </data>
  <data name="Kills" xml:space="preserve">
    <value>kills</value>
  </data>
  <data name="LetsGo" xml:space="preserve">
    <value>Vamos lá</value>
  </data>
  <data name="LowesPickrate" xml:space="preserve">
    <value>O mais baixo Pickrate</value>
  </data>
  <data name="LowestAvgCS" xml:space="preserve">
    <value>assistências Avg CS</value>
  </data>
  <data name="LowestWinrate" xml:space="preserve">
    <value>O mais baixo Winrate</value>
  </data>
  <data name="Mage" xml:space="preserve">
    <value>mago</value>
  </data>
  <data name="Marksman" xml:space="preserve">
    <value>bom atirador</value>
  </data>
  <data name="MercPopularity" xml:space="preserve">
    <value>Mercenary popularidade</value>
  </data>
  <data name="OnlyBilgewater" xml:space="preserve">
    <value>Somente Bilgewater</value>
  </data>
  <data name="Pickrate" xml:space="preserve">
    <value>Pickrate</value>
  </data>
  <data name="Presentation" xml:space="preserve">
    <value>apresentação</value>
  </data>
  <data name="PresentationText1" xml:space="preserve">
    <value>Para a concepção do site, nós usamos {0} com o tema. Com inicialização pode ser relativamente fácil para criar um layout elegante. Para os gráficos, optamos para a biblioteca javascript {1}. Esta é usar relativamente confortável, mas nós tivemos que fazer um pequeno ajuste, a fim de exibir os ícones na lata eixo-X.</value>
  </data>
  <data name="PresentationText2" xml:space="preserve">
    <value>Outras tecnologias</value>
  </data>
  <data name="Region" xml:space="preserve">
    <value>região</value>
  </data>
  <data name="RoleStats" xml:space="preserve">
    <value>Desempenho Estatísticas Papel</value>
  </data>
  <data name="Support" xml:space="preserve">
    <value>apoio</value>
  </data>
  <data name="Tank" xml:space="preserve">
    <value>tanque</value>
  </data>
  <data name="TearNote" xml:space="preserve">
    <value>A lágrima representa os casos em que o jogador não escolher qualquer um dos mercanaries.</value>
  </data>
  <data name="Tools" xml:space="preserve">
    <value>ferramentas</value>
  </data>
  <data name="ToolsText1" xml:space="preserve">
    <value>Para o desenvolvimento utilizou-se principalmente {0}. O ambiente de desenvolvimento Microsoft formulário está disponível gratuitamente, em não-comerciais projectos. Ele torna o desenvolvimento MVC Webapplications muito fácil.</value>
  </data>
  <data name="ToolsText2" xml:space="preserve">
    <value>Além do Programa oferece uma GIT-Integração muito simples e uma opção para publicar seu projeto sem complicações em seu {0}. Também cada biblioteca adicional pode ser obtida através da integração easyly nuget em seu projeto. Fizemos isso para todas as nossas bibliotecas externas.</value>
  </data>
  <data name="TopAvgCS" xml:space="preserve">
    <value>Top Avg CS</value>
  </data>
  <data name="TopPickrate" xml:space="preserve">
    <value>Top Pickrate</value>
  </data>
  <data name="TopWinrate" xml:space="preserve">
    <value>Top Winrate</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>bem-vindo</value>
  </data>
  <data name="WelcomeText1" xml:space="preserve">
    <value>Com a nossa entrada para a API-Challenge 2.0 queríamos dedicar-se ao 1. de possíveis tópicos:</value>
  </data>
  <data name="WelcomeText2" xml:space="preserve">
    <value>Nós pensamos sobre qual das informações pode ser interessante. Nosso principal objetivo foi analisar quais os mercenários eram mais populares entre o playerbase e se o gamelength seriam afetados por asseclas mais fortes.</value>
  </data>
  <data name="WelcomeText3" xml:space="preserve">
    <value>Como um complemento nós adicionamos algumas estatísticas de desempenho de cada campeão e item.</value>
  </data>
  <data name="Winrate" xml:space="preserve">
    <value>Winrate</value>
  </data>
  <data name="ConclusionChampions" xml:space="preserve">
    <value>A maior diferença sobre todos os campeões é a perda significativa no CS por todo o lado. Todos os agricultores de topo em bilgewater são cerca de 20% menor em fazenda.</value>
  </data>
  <data name="ConclusionDuration" xml:space="preserve">
    <value>A duração de partidas Bilgewater defenitly é mais rápido. A maioria das metas são earlyier tomadas, exceto Drake.</value>
  </data>
  <data name="ConclusionMercPopularity" xml:space="preserve">
    <value>Os mercenários corpo a corpo parecem ser mais popular, mas o winrate é justo distribuído. Um grande número surpreendente de jogadores, não comprar um mercenário.</value>
  </data>
  <data name="ConclusionRoles" xml:space="preserve">
    <value>Não é grande variancy em caso de sucesso de diferentes papéis. Empurrão menor em tanque e lutador.</value>
  </data>
</root>